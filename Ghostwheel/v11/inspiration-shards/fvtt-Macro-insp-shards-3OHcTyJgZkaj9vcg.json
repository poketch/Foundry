{
  "name": "insp-shards",
  "type": "script",
  "author": "4ft25hP617oXIBoS",
  "img": "icons/svg/dice-target.svg",
  "scope": "global",
  "command": "// Increment Insp counter \nHooks.on(\"dnd5e.rollToolCheck\", tool);\nHooks.on(\"dnd5e.rollAbilityTest\", ability);\nHooks.on(\"dnd5e.rollSkill\", skill);\n\n// Apply Insp Effects\nHooks.on(\"dnd5e.preRollToolCheck\", (...args) => { return insp(\"tool\", ...args) });\nHooks.on(\"dnd5e.preRollAbilityTest\", (...args) => { return insp(\"check\", ...args) });\nHooks.on(\"dnd5e.preRollSkill\", (...args) => { return insp(\"skill\", ...args); });\nHooks.on(\"dnd5e.preRollAttack\", (...args) => { return insp(\"attack\", ...args); });\n// Hooks.on(\"dnd5e.preRollAbilitySave\", (...args) => { return insp(\"save\", ...args); });\n// Hooks.on(\"midi-qol.preambleComplete\", (w) => { return flag(w) });\n\nconst eff_name = \"GM Inspiration\";\n\nfunction flag(workflow) {\n\n    const inspiredTargets = [...workflow.targets.map(t => t.actor).filter(a => a.effects.some(eff => eff.label === \"GM Inspiration\"))];\n\n    console.log(workflow.uuid);\n\n    for (const target of inspiredTargets) {\n        target.setFlag(\"world\", \"workflowItem\", workflow.uuid);\n    }\n\n\n    // if it's a spell I need to interupt here for insp dialog\n\n}\n\nfunction insp(type, ...args) {\n\n\n    let actor = args[0];\n\n    if (type === \"tool\" || type === \"attack\") {\n        actor = args[0].actor;\n    }\n\n    if (actor.flags?.world?.skipInsp === true) {\n        actor.setFlag(\"world\", \"skipInsp\", false);\n        return;\n    }\n\n    const effect = actor.effects.filter(eff => eff.label === eff_name)[0];\n\n    if (effect === undefined || effect === null) { return; }\n\n    new Dialog({\n        title: \"INSPIRED!\",\n        content: \"You have GM Inspiration, Do you want to use it?\",\n        buttons: {\n            YES: {\n                label: \"YES!\", callback: async () => {\n                    await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: actor.uuid, effects: [effect.id] })\n                    await outcome(actor, type, true, ...args);\n                }\n            },\n            NO: {\n                label: \"no...\",\n                callback: async () => {\n                    await actor.setFlag(\"world\", \"skipInsp\", true);\n                    await outcome(actor, type, false, ...args);\n                }\n            },\n        },\n    }).render(true);\n    return false;\n}\n\nasync function outcome(actor, type, adv, ...args) {\n\n    let options;\n\n    switch (type) {\n        case \"skill\":\n            await actor.rollSkill(args[2], { advantage: adv, fastForward: true });\n            break;\n        case \"check\":\n            await actor.rollAbilityTest(args[2], { advantage: adv, fastForward: true });\n            break;\n        case \"tool\":\n            const w = await MidiQOL.Workflow.getWorkflow(args[0].uuid);\n            console.log(w);\n            await args[0].rollToolCheck({ advantage: adv, fastForward: true }); //item.rollToolCheck on the requisiute tool\n            break;\n        case \"save\":\n\n            const targets = game.users.map(u => [...u.targets]).flat().map(t => t.actor);\n\n            if (!targets.includes(actor)) {\n                //lazy save\n                await actor.rollAbilitySave(args[2], { advantage: adv, fastForward: true });\n                break;\n            }\n\n            const item = await fromUuid(actor.flags?.world?.workflowItem);\n            if (!item) { return; }\n\n            if (adv) {\n                let z = actor;\n                z.actor = actor;\n                await game.macros.getName(\"save_buff\").execute({ actor: [{ targets: [z] }] });\n            }\n\n            options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n            await MidiQOL.completeItemUse(item, {}, options);\n            actor.unsetFlag(\"world\", \"workflowItem\");\n            break;\n        case \"attack\":\n            await args[0].rollAttack({ advantage: adv, fastForward: true })\n            break;\n    }\n}\n\nasync function shard(type, actor) {\n\n    if (game.combat != null) { return; }\n\n    let actorUuiD = actor.uuid;\n    let itemUuiD = actor.items.filter(it => it.name === \"Inspiration Shards\")[0].uuid;\n\n    await Requestor.request({\n        img: false,\n        title: `${actor.name}: ${type} check`,\n        description: `Looks like ${actor.name} made a check. What was the outcome?`,\n        buttonData: [\n            {\n                label: `Success`,\n                command: async () => {\n\n                    const item = await fromUuid(itemID);\n                    const actor = await fromUuid(actorID);\n\n                    const uses = item.system.uses.value;\n\n                    if (uses === 4) {\n\n                        await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actor.uuid, effects: [[...item.effects][0]] });\n                        await item.update({ \"system.uses.value\": 0 });\n                        const message = game.messages.filter(msg => msg.content.includes(\"requestor\") && msg.content.includes(`${actor.name}`)).last();\n                        await message.delete();\n                        return;\n                    }\n\n                    await item.update({ \"system.uses.value\": uses + 1 });\n                    const messages = game.messages.filter(msg => msg.content.includes(\"requestor\") && msg.content.includes(`${actor.name}`));\n                    const message = messages[messages.length - 1];\n                    await message.delete();\n                    return;\n\n                },\n                scope: { actorID: actorUuiD, itemID: itemUuiD },\n                limit: Requestor.LIMIT.OPTION,\n                permission: Requestor.PERMISSION.GM\n            },\n            {\n                actor: actorUuiD,\n                label: \"Failure\",\n                command: async () => {\n                    const actor = await fromUuid(this.actor);\n                    const messages = game.messages.filter(msg => msg.content.includes(\"requestor\") && msg.content.includes(`${actor.name}`));\n                    const message = messages[messages.length - 1];\n                    await message.delete();\n                    return;\n\n                },\n                scope: { actor: actorUuiD, item: itemUuiD },\n                limit: Requestor.LIMIT.OPTION,\n                permission: Requestor.PERMISSION.GM\n            }\n        ],\n\n        limit: Requestor.LIMIT.OPTION,\n        whisper: game.users.filter(user => user.isGM).map(user => user.id),\n        blind: true,\n    });\n}\n\nfunction skill(...args) {\n    shard(\"skill\", args[0]);\n}\n\nfunction ability(...args) {\n    shard(\"ability\", args[0]);\n}\n\nfunction tool(...args) {\n    shard(\"tool\", args[0].actor);\n}",
  "flags": {
    "combat-utility-belt": {
      "macroTrigger": ""
    },
    "core": {},
    "exportSource": {
      "world": "ddf-friends-characters",
      "system": "dnd5e",
      "coreVersion": "11.308",
      "systemVersion": "2.3.1"
    }
  },
  "_stats": {
    "systemId": "dnd5e",
    "systemVersion": "2.3.1",
    "coreVersion": "11.308",
    "createdTime": 1667580290658,
    "modifiedTime": 1693514732919,
    "lastModifiedBy": "4ft25hP617oXIBoS"
  },
  "folder": null
}